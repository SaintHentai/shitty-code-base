# **Самый сбалансированный раздел**

Вы разрабатываете программу для оптимизации хранения данных на диске. У вас есть дерево файловой системы, представленное с помощью списка родителей и списка размеров файлов. Вам нужно найти самый сбалансированный способ разбиения дерева на две части.

Функция **`mostBalancedPartition(parent, files_size)`** принимает два списка: **`parent`** и **`files_size`**. Список **`parent`** представляет родительские индексы каждого узла в дереве, а список **`files_size`** содержит размеры файлов для каждого узла.

Функция должна вернуть минимальную разницу в суммах размеров файлов между двумя разделами дерева.

## **Формат входных данных:**

- **`parent`**: Список целых чисел, представляющих родительские индексы каждого узла в дереве. Индекс 0 обозначает корень дерева.
- **`files_size`**: Список целых чисел, представляющих размеры файлов для каждого узла в дереве.

Входные данные:    **parent = [0, 1, 1, 2] files_size = [10, 5, 8, 3]**

Выходные данные: 8

## **Общие решение:**

### Вычисление общего веса дерева:

Сначала мы вычисляем общий вес всего дерева, суммируя веса всех файлов в дереве.

### Рекурсивный обход дерева для подсчета весов поддеревьев:

Мы начинаем с корня дерева и рекурсивно проходим по всем узлам. Для каждого узла мы вычисляем вес его поддерева, включая его самого. Мы суммируем веса всех файлов для узла и его детей.

### Нахождение минимальной разницы между весами двух поддеревьев:

После того как мы вычислили веса для каждого поддерева, мы находим разницу между весами левого и правого поддеревьев. Мы выбираем минимальную разницу в качестве ответа.

### Возвращение ответа:

Минимальная разница в весах двух поддеревьев будет нашим ответом.

### **Структура дерева:**

```
   0
   |
   1
  / \
 2   3
```

### Значения в дереве:

```
      0 (files_size = 10)
      |
      1 (files_size = 5)
     / \
    2   3 (files_size = 8 and 3)
```

- Узел с индексом 0 имеет размер файла 10.
- Узел с индексом 1 имеет размер файла 5.
- Узел с индексом 2 имеет размер файла 8.
- Узел с индексом 3 имеет размер файла 3.

## Подробное решение:

### Вычисление общего веса дерева:

   Общий вес = 10 (узел 0) + 5 (узел 1) + 8 (узел 2) + 3 (узел 3) = 26.

### Рекурсивный обход дерева для подсчета весов поддеревьев:

1. Начнем с корня дерева, узла с индексом 0. Его вес равен 10.
2. Теперь рекурсивно рассмотрим каждого его ребенка:
    - Узел с индексом 1. Его вес равен 5.
        - Теперь рекурсивно рассмотрим каждого его ребенка:
            - Узел с индексом 2. Его вес равен 8.
            - Узел с индексом 3. Его вес равен 3.
        - Общий вес поддерева узла 1 (включая его самого) равен 5 + 8 + 3 = 16.
    - Общий вес поддерева узла 0 (включая его самого и всех его детей) равен 10 + 16 = 26.
    
    ### Подытожим наши рек. вычисления:
    
    - Общий вес всего дерева: 26
    - Вес поддерева для узла 0 (включая его самого и всех его детей): 26
    - Вес поддерева для узла 1 (включая его самого и всех его детей): 16
    - Вес поддерева для узла 2 (включая его самого): 8
    
    ### Нахождение минимальной разницы между весами двух поддеревьев:
    
    - Разница между весами поддерева для узлов 0 и 1: |26 - 16| = 10
    - Разница между весами поддерева для узлов 0 и 2: |26 - 8| = 18
    - Разница между весами поддерева для узлов 1 и 2: |16 - 8| = 8
    
    Минимальная разница из этих значений равна 8. Таким образом, минимальная разница между весами двух поддеревьев составляет 8.
    
    Этот шаг позволяет нам найти наименьшую разницу весов между левым и правым поддеревьями, что может быть важно для определения баланса дерева.
    
    ### **Тест:**
    
    Давайте протестируем этот код с примером:
    
    ### **Входные данные:**
    
    - **`parent = [0, 1, 1, 2]`**
    - **`files_size = [10, 5, 8, 3]`**
    
    ### **Ожидаемый результат:**
    
    - Ожидаемый результат: **`8`**
    
    ### **Проверка:**
    
    1. Построим дерево:
        
        ```markdown
        
           0
            \
             1
            / \
           2   3
        ```
        
    2. Значения в дереве:
        
        ```scss
        
           0 (10)
            \
             1 (5)
            / \
           2   3
          (8) (3)
        ```
        
    3. Вес поддеревьев:
        - Общий вес дерева: **`26`**
        - Вес поддерева для узла **`0`**: **`26`**
        - Вес поддерева для узла **`1`**: **`16`**
        - Вес поддерева для узла **`2`**: **`8`**
    4. Минимальная разница:
        - Разница между весами поддеревьев: **`|26 - 2 * 16| = 6`** и **`|26 - 2 * 8| = 10`**
    
    ### **Пошаговое выполнение:**
    
    1. **Инициализация:**
        - **`children = [[], [2, 3], [3], []]`**
        - **`size_sums = [0, 0, 0, 0]`**
    2. **Рекурсивный расчет весов поддеревьев:**
        - **`size_sums_rec(3)`**: **`size_sums[3] = 3`**
        - **`size_sums_rec(2)`**: **`size_sums[2] = 8 + 3 = 11`** (ошибка, не должно учитывать 3 как своего ребенка)
        - **`size_sums_rec(1)`**: **`size_sums[1] = 5 + 8 + 3 = 16`**
        - **`size_sums_rec(0)`**: **`size_sums[0] = 10 + 16 = 26`**
